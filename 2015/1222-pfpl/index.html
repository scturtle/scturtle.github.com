<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>PFPL 读书笔记和闲言碎语 | ScTurtle&#39;s Pool</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link rel="stylesheet" href="/static/pygments.css" type="text/css">
    <link href="/atom.xml" rel="alternate" title="ScTurtle&#39;s Pool" type="application/atom+xml">
  </head>
  <body>
    <div class=container>
      <div class=header>
        <a class=site-name href='/'>ScTurtle&#39;s Pool</a>
        <nav class=navigation>
          <a href='/'>blog</a>
          <a href='/archive.html'>archive</a>
          <a href='/tags/'>tags</a>
          <a href='/about/'>about</a>
        </nav>
      </div>
      <div class=body>


<article>
<h1 class=title>PFPL 读书笔记和闲言碎语</h1>
<p class=info>
Dec 22, 2015
<a href='/tags/PLT.html'>#PLT</a>
</p>
<p><a href="http://www.cs.cmu.edu/~rwh/plbook/1sted-revised.pdf">Practical Foundations for Programming Languages</a> 是一本介绍编程语言理论（PLT, programming language theory）和类型论（type theory）的书。
和另一本传说中的书 <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> 相比，更新内容也更广，不拘于一门编程语言，通篇的数学更简洁虽然也更难懂一些。
此外，在介绍的各种类型系统（type system）时，书里特意标出哪些规则是 call by name 那些是 call by value 的，很好地避免了单一一门语言对及早（eager）还是惰性求值的偏颇。
作者的大名也是不能更响，不管是第一版还是修订中的第二版都在网上放出 pdf 实属业界良心。</p>
<p>呃说起来 PLT 范围很广，从 Lisp/Scheme 的各种奇技淫巧，到 Haskell 从范畴论借来的各种花哨术语，再到不知何年何月才足够实用的 dependent type，摆脱不了的基础便是各种类型系统（type system）和背后的类型论了。
不过就像 PLT 其实没啥用处一样，看了这本书也并不会对写代码有什么帮助。
但是这本书会把各种语言的各种特性纳入一个统一的框架（类型论）中，告诉你哪些真能提升语言的表达能力，哪些特性是扯淡的，哪些看起来很绚丽的其实是另一些特性的组合。
了解这些呢有助于避免被某些新出语言的广告词所欺骗，也可以在永无停歇的语言互黑大战获得高屋建瓴一针见血的能力。</p>
<p>因为章节很碎（18部分，49章）,下面试图总结性地写一写，算是给自己的笔记，和近来多无所事事的交代。</p>
<p>Preface 有一句很有意思的话，感觉开了地图炮啊233：</p>
<blockquote>
<p>If language design and programming methodology are to advance from a trade-craft to a rigorous discipline, it is essential that we first get the definitions right.</p>
</blockquote>
<p>第一部分叫做 Judgments and Rules。基本上是各种常用的定义、符号和推导形式。呃其实就是证明论（proof theory）里那堆东西拿过来又叨叨了一遍。话说 proof theory、type theory 和 category theory 这三者虽然分别来自逻辑学、计算机和数学，但是现在互相打通（<a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">CCC</a>, <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry–Howard correspondence</a>）之后来看，不得不说计算机还真是一门科学。作者本人也曾在讲座中 troll 过：</p>
<blockquote>
<p>Math itself is just a corner of computer science. Computer science is the queen of sciences. —— Robert Harper</p>
</blockquote>
<p>第二部分叫做 Statics and Dynamics。讲的是语言区分为静态部分和动态部分。
静态部分指语法和类型规则，语言在执行静态检查时会进行类型推断和检查，这时便可以剔除一些显而易见的类型错误。
动态规则指运行时如何从表达式一步一步运行得到值。
一个语言的类型系统既包括静态部分也包括动态部分，一个类型系统是否安全（type safety）也包括两个部分：preservation 和 progress。
前者要给你们看到，我静态分析这个表达式是这个类型，你动态运行每一步也是这个类型（没有特技）。
后者则是说，我静态检查通过了，你动态运行不会还没得到值就因为类型不符进行不下去了。
不过后者并不能排除除以零这种类型正确的运行时错误。
说起来静态部分做的工作越多，动态时出错的可能性也就更少，这也是为什么需要越来越高级的 type system 的原因。
不过到了 dependent type 这个地步，静态部分都不一定能停机了，还得程序员自己来证明并嵌入代码中，真的会有实用的一天么？……
最后这里还引用了一句著名广告词233：</p>
<blockquote>
<p>well-typed programs do not go wrong. —— Robin Milner</p>
</blockquote>
<p>第三部分叫做 Total Functions，引入了函数的定义和 system T。
在第二部分第四章介绍类型系统的时候，曾引入本书的的第一个类型系统 <code>language E</code>, 包括简单的数字、字符串、几个运算函数和 let 绑定。
这里先扩展 <code>E</code> 为 <code>ED</code> 添加了简单的函数定义和函数应用。
进而，引入 <mathjax>$\lambda$</mathjax> function 并加入函数类型作为一等公民，实现了高阶函数（higher-order function），扩展 <code>E</code> 为 <code>EF</code>。
实现 <mathjax>$\lambda$</mathjax> function 的时候，会有作用域的问题，解释时使用替换（substitution）没问题但是没嵌套作用域（nesting scoping）的 mapping environment 会有问题。
这也是为什么实际中实现 <mathjax>$\lambda$</mathjax> function 需要闭包（closure）的原因。</p>
<p>System T 又叫做 Gödel's T，只包括包括上面的高阶函数和Peano 数（<code>Z, S(Z), S(S(Z))</code>……）表示的自然数和原始递归（primitive recursion），是异常简单同时也非常重要的一个类型系统。
原始递归是建立在像剥洋葱一样层层剥离 Peano 数基础上的递归，如果参数是 Z 也就是 0 的话就返回，如果是 S(e) 就对 e 继续递归。相当于每次递归的时候参数减一，所以是一定会停机的。
这说明 T 里面只能定义 total function，也就是像纯粹的数学函数一样，对定义域的每个输入都一定会返回值，而不会像 partial function 一样在某些定义域上未定义或者在计算中陷入了死循环。
（换句话说，system T 里的递归是自带 termination proof 的。）</p>
<p>咋一看这货根本不行啊，连一个最简单的死循环函数都写不出来啊。
文中用了的 Gödel's encoding 和对角线法（diagonalization）那套用来证明不完备的方法，来证明 T 中确实有无法定义的函数，比如一个自身的解释器，所以说 T 并不是图灵完备的。
可以说 system T 虽然抛弃了 universality 但是获得了 totality。
咋一看图灵完备都做不到有个毛用，但是 totality 在形式证明（formal proof）中却是必要的，因为一个不停机的证明什么也说明不了。
而且在 dependent type system 中，类型可能会依赖于值，所以 totality 对于类型检查能否停机也是至关重要的。
这也是 Coq、Idris 和 Agda 这类 <a href="http://www.wikiwand.com/en/Total_functional_programming">total functional programming</a> 的基础。</p>
<p>第四部分叫做 Finite Data Types。介绍了 product type 和 sum type 两种组合已有类型得到新类型的最基本的方法。
Product type 类比于常见的元祖（tuple）。比如（Int, String）这个类型的值的个数 = Int 的值得个数 <mathjax>$\times$</mathjax> String 的值的个数。
那么乘法的单位元 <mathjax>$\mathfrak{1}$</mathjax> 是什么呢？是空元祖类型也叫做 Unit，它的特点就是只有一个值 <code>()</code>。
Product type 有一个有趣的应用是可以用来实现像 odd 和 even 这种互相交叉定义的递归函数（primitive mutual recursion）。说白了就是递归时用元祖来同时计算所有函数啦。</p>
<blockquote>
<p>Sums codify heterogeneity.</p>
</blockquote>
<p>Sum type 则对应着类型“和”。比如 Haskell 里面的 <code>data Bool = True | False</code>，如果把 <code>True</code> 和 <code>False</code> 分别看做只有一个值的类型，那么 <code>Bool</code> 的值的个数就是 1+1=2。
另一个常见的 sum type 是 <code>data Maybe a = Nothing | Just a</code>（很多语言里面的 <code>option</code>），值的个数是类型 a 的值的个数加一。
“和”的单位元 <mathjax>$\mathfrak{0}$</mathjax> 是类型 Void，其特点是……没有值，所以“加”什么还是什么。
这里的 Void 和 C/C++ 里面的 void 是不同的，后者其实是前面提到的 Unit，而前者没有任何值所以既不能被当做参数也不能被当做返回值（正常情况下……）。
<!-- “null pointer fallacy” 不再赘述。 --></p>
<p>第五部分是 Types and Propositions。说的是 constructive logic（构造性逻辑，又叫 <a href="https://en.wikipedia.org/wiki/Intuitionistic_logic">intuitionistic logic</a>，直觉主义逻辑）和 <a href="https://en.wikipedia.org/wiki/Classical_logic">classical logic</a>（经典逻辑）之间的恩怨纠葛。
经典逻辑是我们熟悉的形式逻辑，包括命题为真，为假，和 <mathjax>$\top$</mathjax> (truth), <mathjax>$\bot$</mathjax> (falsity), <mathjax>$\vee$</mathjax> (or), <mathjax>$\wedge$</mathjax> (and), <mathjax>$\subset$</mathjax> (imply)。
经典逻辑中任一命题要么为真要么为假，没有中间状态，叫做排中律（LEM, <a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">law of the excluded middle</a>），表示为 <mathjax>$P \vee \neg P\ true$</mathjax>。</p>
<blockquote>
<p>Constructive logic codiﬁes the principles of mathematical reasoning as it is actually practiced.</p>
</blockquote>
<p>构造性逻辑则拿掉了排中律，命题为真必须给出证明，为假则必须给出反驳，两者都必须构建在一个又一个的证明或者反驳之上。
比如，虽然我们知道要么 <mathjax>$P = NP$</mathjax> 要么 <mathjax>$P \neq NP$</mathjax>，但是我们目前既不能给出前者的证明也给不出后者的证明（来反驳前者），所以不能用这两个证明中的任意一个来构建一个 <mathjax>$\vee$</mathjax>。
这样的好处是，构造性逻辑能更好地反映现实中的数学推理，现实中总是充满了各种未解决的问题，像 <mathjax>$P \stackrel{?}{=} NP$</mathjax> 这种目前还只有上帝才知道，还是留给他老人家来用吧。</p>
<blockquote>
<p>There is no guarantee of success! Life is hard, but we muddle through somehow.</p>
</blockquote>
<p>另一方面，证明的构造性和计算机程序有着极其相似的结构，一个表达式对于一个特定的类型来说就像一个证明对于命题一样重要。
这种逻辑和程序奇妙的统一性叫做“propositions as type”。具体表现为：<mathjax>$\top$</mathjax> 和 Unit，<mathjax>$\bot$</mathjax> 和 Void，<mathjax>$\wedge$</mathjax> 和 product，<mathjax>$\vee$</mathjax> 和 sum，<mathjax>$\subset$</mathjax> 和 <mathjax>$\lambda$</mathjax> 分别是一一对应的。
一个命题对应一个类型，一个证明对应一个程序，又叫做 <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry-Howard correspondence</a>。</p>
<p>看似从经典逻辑中拿掉了不切实际的排中律，可以建立起逻辑和计算机之间深刻的联系，却必须以牺牲表达能力为代价，实际上并不是！
可以证明的是构造性逻辑 <em>不拒绝</em> 排中律。在需要的时候可以将特定命题的排中律拿来当假设用，所以经典逻辑完全可以在构造性逻辑中表达，只是不能随便开上帝模式了。
Mind blown! 后面还会继续出现这种 less is more 的栗子。</p>
<blockquote>
<p>In programming language terms adding a “feature” does not necessarily strengthen (improve the expressive power) of your language; on the contrary, it may weaken it.</p>
</blockquote>
<p>第六部分为 Infinite Data Types。
Generic programming 这章简单引入了带类型变量的类型 <mathjax>$t.\tau$</mathjax>。
其中 <mathjax>$\tau$</mathjax> 是由 <mathjax>$t$</mathjax> 和 void/unit/product/sum 组合的类型。
值得注意的是在扩展 <mathjax>$\tau$</mathjax> 到函数时（<mathjax>$t.\ \tau_1 \rightarrow \tau_2$</mathjax>），需要保证 positivity 也就是 t 不能出现在定义域的位置（<mathjax>$\tau_1$</mathjax>）。
其实这说的就是 functor 和 fmap 啊，引入这几个抽象概念是为了方便随后定义两种递归类型。</p>
<p>从名字就可以看出 Inductive types 和 coinductive types 是两个互为 dual 的概念。
前者定义在引进规则（introduction forms）上的，呃，就是定义在“怎么定义”上……
以其为参数的递归函数的一般形式（catamorphism）是先递归再替换。
举例来说 Peano 数，每一个值要么是零要么是另一个值的后继。而参数是 Peano 的递归函数先在前驱上递归计算，再计算当前数上的值。
而 coindoctive types 定义在消除规则（elimination forms）上，嗯……算是“怎么来用”上……
以其为参数的的递归函数的一般形式（anamorphism）也相反，是先替换再递归。
通常拿来举的例子是一个无限的数据流（stream），比如斐波那契数列，每一项都是前两项的和，必须先计算完数列前面的值才能得到后面的值的数列。
如果说 inductive types 的函数更像传统意义上的递归函数（recursor）的话，那么 coinduvtive types 的函数则更像是根据指定规则的一个产生器（generator）。</p>
<p>这是两种最典型的递归形式（recursion scheme），区分它们的必要性在于，他们是同一个类型等式（type equations）的两个极端解（类型）。
例如上面提到过的 Peano number 和 stream 显然都是 <mathjax>$x = 1 \times x$</mathjax> 的形式，却又不同并互为 dual。
理论上来说 inductive types 是类型等式的最小解（smallest/least/most restrictive），而 coinductive types 是最大解（largest/greatest/most permissive）。
另一种对称性在于，前者虽然有无限个值，但是每一个值都是在有限步内构造的；而后者则构造了一个无限的序列，在有限步内析构会得到有限个值。
假若不加区分的将一个前者的函数应用在后者上就死循环了，所以强调 totality 的 Idris、Agda 等语言中显示地区分这两种概念。
从两者函数行为的区别上也可以看出，支持惰性求值才能支持先替换后递归，这也是为什么 Haskell 里面能这么简单实现无限序列的缘故。
逼逼了这么多不过下面这句话我到现在还不是很理解……</p>
<blockquote>
<p>Inductive types are initial algebras and coinductive types are ﬁnal coalgebras for the functor given by a (polynomial or positive) type operator.</p>
</blockquote>
<p>(待续……)</p>
</article>
<div id="show_disqus"><a onclick="load_disqus();return false;" href="##">Show comments</a></div>
<div id="disqus_thread"></div>


      </div>
      <div class=footer>
        <p><a href='https://github.com/scturtle/turtleblog'>turtleblog</a> &copy;
        <script>document.write(new Date().getFullYear());</script> scturtle
        <p> <a href="mailto:scturtle@gmail.com">mail</a>,
        <a href="https://twitter.com/scturtle">twitter</a>,
        <a href="https://github.com/scturtle">github</a>,
        <a href='/atom.xml' rel=alternate title="Recent Blogs | ScTurtle&#39;s Pool">feed</a>
      </div>
    </div>

<script type="text/javascript">
  function load_disqus() {
    var disqus_shortname = 'scturtlespool';
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    document.getElementById('show_disqus').style.display='none';
  };
</script>

<script type="text/javascript" 
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<script type="text/x-mathjax-config"> 
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ["\\(","\\)"]],
    processEscapes: true
  },
}); </script>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33410961-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>