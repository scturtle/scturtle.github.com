<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>PFPL 读书笔记和闲言碎语 | ScTurtle&#39;s Pool</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" href="/static/style.css" type="text/css">
    <link rel="stylesheet" href="/static/pygments.css" type="text/css">
    <link href="/atom.xml" rel="alternate" title="ScTurtle&#39;s Pool" type="application/atom+xml">
  </head>
  <body>
    <div class=container>
      <div class=header>
        <a class=site-name href='/'>ScTurtle&#39;s Pool</a>
        <nav class=navigation>
          <a href='/'>blog</a>
          <a href='/archive.html'>archive</a>
          <a href='/tags/'>tags</a>
          <a href='/about/'>about</a>
        </nav>
      </div>
      <div class=body>


<article>
<h1 class=title>PFPL 读书笔记和闲言碎语</h1>
<p class=info>
Dec 22, 2015
<a href='/tags/PLT.html'>#PLT</a>
</p>
<p><a href="http://www.cs.cmu.edu/~rwh/plbook/1sted-revised.pdf">Practical Foundations for Programming Languages</a> 是一本介绍编程语言理论（PLT, programming language theory）和类型论（type theory）的书。
和另一本传说中的书 <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> 相比年代更新内容也更广泛，并 不拘于一门编程语言而是通篇数学阐释，更简洁当然也更难懂一些。
此外，在介绍的各种类型系统（type system）时，作者特意标出哪些规则是 call by name 那些是 call by value 的，很好地避免了单一一门语言对 strict 还是 lazy 的偏颇。
作者的大名不能更响，不管是第一版还是修订中的第二版都在网上放出 pdf 实属业界良心。</p>
<p>呃说起来 PLT 范围很广，从 Lisp/Scheme 的各种奇技淫巧，到 Haskell 从范畴论借来的各种花哨术语，再到不知何年何月才足够实用的 dependent type，摆脱不了的基础便是各种类型系统（type system）和背后的类型论了。
不过就像 PLT 其实没啥用处一样，看了这本书也并不会对写代码有什么帮助。
但是这本书会把各种语言的各种特性纳入一个统一的框架（类型论）中，告诉你哪些真能提升语言的表达能力，哪些特性是扯淡的，哪些看起来很绚丽的其实是另一些特性的组合。
了解这些呢有助于避免被某些新出语言的广告词所欺骗，也可以在永无停歇的语言互黑大战获得高屋建瓴一针见血的能力。</p>
<p>因为章节很碎（18部分，49章）,下面试图总结性地写一写，算是给自己的笔记，和近来多无所事事的交代。</p>
<p>Preface 有一句很有意思的话，感觉开了地图炮啊233：</p>
<blockquote>
<p>If language design and programming methodology are to advance from a trade-craft to a rigorous discipline, it is essential that we first get the definitions right.</p>
</blockquote>
<p>第一部分叫做 Judgments and Rules。基本上是各种常用的定义、符号和推导形式。呃其实就是证明论（proof theory）里那堆东西拿过来又叨叨了一遍。话说 proof theory、type theory 和 category theory 这三者虽然分别来自逻辑学、计算机和数学，但是现在互相打通（<a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">CCC</a>, <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">Curry–Howard correspondence</a>）之后来看，不得不说计算机还真是一门科学。作者本人也曾在讲座中 troll 过：</p>
<blockquote>
<p>Math itself is just a corner of computer science. Computer science is the queen of sciences. —— Robert Harper</p>
</blockquote>
<p>第二部分叫做 Statics and Dynamics。讲的是语言区分为静态部分和动态部分。
静态部分指语法和类型规则，语言在执行静态检查时会进行类型推断和检查，这时便可以剔除一些显而易见的类型错误。
动态规则指运行时如何从表达式一步一步运行得到值。
一个语言的类型系统既包括静态部分也包括动态部分，一个类型系统是否安全（type safety）也包括两个部分：preservation 和 progress。
前者要给你们看到，我静态分析这个表达式是这个类型，你动态运行每一步也是这个类型（没有特技）。
后者则是说，我静态检查通过了，你动态运行不会还没得到值就因为类型不符进行不下去了。
不过后者并不能排除除以零这种类型正确的运行时错误。
说起来静态部分做的工作越多，动态时出错的可能性也就更少，这也是为什么需要越来越高级的 type system 的原因。
不过到了 dependent type 这个地步，静态部分都不一定能停机了，还得程序员自己来证明并嵌入代码中，真的会有实用的一天么？……
最后这里还引用了一句著名广告词233：</p>
<blockquote>
<p>well-typed programs do not go wrong. —— Robin Milner</p>
</blockquote>
<p>第三部分叫做 Total Functions，引入了函数的定义和 system T。
在第二部分第四章介绍类型系统的时候，曾引入本书的的第一个类型系统 <code>language E</code>, 包括简单的数字、字符串、几个运算函数和 let 绑定。
这里先扩展 <code>E</code> 为 <code>ED</code> 添加了简单的函数定义和函数应用。
进而，引入 <mathjax>$\lambda$</mathjax> function 并加入函数类型作为一等公民，实现了高阶函数（higher-order function），扩展 <code>E</code> 为 <code>EF</code>。
实现 <mathjax>$\lambda$</mathjax> function 的时候，会有作用域的问题，解释时使用替换（substitution）没问题但是没嵌套作用域（nesting scoping）的 mapping environment 会有问题。
这也是为什么实际中实现 <mathjax>$\lambda$</mathjax> function 需要闭包（closure）的原因。</p>
<p>System T 又叫做 Gödel's T，只包括包括上面的高阶函数和Peano 数（<code>Z, S(Z), S(S(Z))</code>……）表示的自然数和原始递归（primitive recursion），是异常简单同时也非常重要的一个类型系统。
原始递归是建立在像剥洋葱一样层层剥离 Peano 数基础上的递归，如果参数是 Z 也就是 0 的话就返回，如果是 S(e) 就对 e 继续递归。相当于每次递归的时候参数减一，所以是一定会停机的。
这说明 T 里面只能定义 total function，也就是像纯粹的数学函数一样，对定义域的每个输入都一定会返回值，而不会像 partial function 一样在某些定义域上未定义或者在计算中陷入了死循环。
（换句话说，system T 里的递归是自带 termination proof 的。）</p>
<p>咋一看这货根本不行啊，连一个最简单的死循环函数都写不出来啊。
文中用了的 Gödel's encoding 和对角线法（diagonalization）那套用来证明不完备的方法，来证明 T 中确实有无法定义的函数，比如一个自身的解释器，所以说 T 并不是图灵完备的。
可以说 system T 虽然抛弃了 universality 但是获得了 totality。
咋一看图灵完备都做不到有个毛用，但是 totality 在形式证明（formal proof）中却是必要的，因为一个不停机的证明什么也说明不了。
而且在 dependent type system 中，类型可能会依赖于值，所以 totality 对于类型检查能否停机也是至关重要的。
这也是 Coq、Idris 和 Agda 这类 <a href="http://www.wikiwand.com/en/Total_functional_programming">total functional programming</a> 的基础。</p>
<p>(待续……)</p>
</article>
<div id="show_disqus"><a onclick="load_disqus();return false;" href="##">Show comments</a></div>
<div id="disqus_thread"></div>


      </div>
      <div class=footer>
        <p><a href='https://github.com/scturtle/turtleblog'>turtleblog</a> &copy;
        <script>document.write(new Date().getFullYear());</script> scturtle
        <p> <a href="mailto:scturtle@gmail.com">mail</a>,
        <a href="https://twitter.com/scturtle">twitter</a>,
        <a href="https://github.com/scturtle">github</a>,
        <a href='/atom.xml' rel=alternate title="Recent Blogs | ScTurtle&#39;s Pool">feed</a>
      </div>
    </div>

<script type="text/javascript">
  function load_disqus() {
    var disqus_shortname = 'scturtlespool';
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    document.getElementById('show_disqus').style.display='none';
  };
</script>

<script type="text/javascript" 
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<script type="text/x-mathjax-config"> 
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ["\\(","\\)"]],
    processEscapes: true
  },
}); </script>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33410961-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>